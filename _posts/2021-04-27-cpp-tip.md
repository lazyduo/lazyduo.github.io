---
title: "cpp tip"
date: 2021-04-27 00:30:00 +0900
categories: diary
classes: wide
---
SW Expert Academy (Samsung) Pro 레벨 테스트 대비
tech tip 정리

## 부분문자열의 suffix 사전 순 배열

suffix로 시작하는 str의 부분 문자열의 사전 순으로 배열 하는 문제인데...

`strcmp(str1, str2)` 이 <0 인 경우가 사전 배열임!!

(생각지도 못했음..)

```cpp
#include <string.h>
#include <algorithm>
using namespace std;

char str[400];
int suffix[400]; // 접두어의 idx

bool compare(const int& a, const int& b) {
    return strcmp(str + a, str + b) < 0; // 사전 순 배열
}

int main()
{
  int strLen = strlen(str);
  for (int i=0; i<strLen; i++)
    suffix[i] = i;
    
  sort(suffix, suffix + strLen, compare); // suffix를 사전 순으로 배열해줌
}
```

## dijkstra 알고리즘과 priority_queue

Heap은 <queue>에서 `priority_queue<>` 과 같이 선언 할 수 있다.
    
이때, 기본이 내림차순이므로 `top()`할 때 가장 큰 수로 나오는 것을 유의해야한다.

따라서, 우선 순위 큐를 뒤집어 주어야하는데 방법이 좀 까다롭다.

pair를 안 쓰면 `priority_queue<int, vector<int>, greater<int>> pq;`로 나름 간단하지만,

pair를 쓰게 되면 아래와 같이 struct 설정하여 **연산자 오버로딩**을 해야한다.

```cpp
#include <vector>
#include <queue>

struct cmp{

    bool operator()(pair<int, int>&a, pair<int, int>&b) {
        return a.second > b.second;
    }
};

priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> pq; // heap
```

이렇게 우선순위큐를 구성을 하면 아래와 같이 dijkstra를 구현 할 수 있다.

```cpp
void dijkstra(int start)
{
    d[start] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> pq; // heap
    pq.emplace(make_pair(start, 0));

    while(!pq.empty()) {
        int current = pq.top().first;
        int distance = pq.top().second;
        pq.pop();

        printf("current : %d\n", current);

        if(d[current] < distance) continue;
        for (int i=0; i < a[current].size(); i++) {
            int next = a[current][i].first;
            int nextDistance = distance + a[current][i].second;
            if (nextDistance < d[next]) {
                d[next] = nextDistance;
                pq.emplace(make_pair(next, nextDistance));
            }
        }

    }
}
```
이때, push보다는 emplace가 대부분 효율적이라고 한다..
